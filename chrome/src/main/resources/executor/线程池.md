#  代码详细com.wzl.chrome.executor.pool.Pool


SDK 和 API  要想使用SDK内部的功能 就必须通过它提供的API接口
    直接点：如果有这个SDK 那么我们就可以想象成他就是我们自己封装的某个功能
            如果没有SDK 我们想要使用这个功能 就需要通过其它的一些方式 比如 http调用SDK的API
            如:淘宝开放平台SDK提供了API的请求封装、摘要签名、响应解释、消息监听等功能，使用SDK可以轻松完成API的调用、API结果的获取、消息的实时监听。
    说白了：源码包
# 线程池的目的: 线程复用、减少线程的频繁创建 降低时间和资源的损耗 线程的创建和执行分开 方便维护
# 原理：
    首先提交任务到线程池（任务都是实现runable或其他方式的接口）
    线程池的创建主要参数释义：
        核心线程数、最大线程数、超出线程存活时间、时间单位、创建线程的工厂、队列（长度）、饱和策略
举个例子： 5             8               60          S           默认          2             拒绝抛异常
        //任务数 a = 3 , 活跃线程数3 , 任务数 < 核心线程数。
        //任务数 a = 4 , 活跃线程数4 , 任务数 < 核心线程数。
        //任务数 a = 5 , 活跃线程数5 , 任务数 = 核心线程数。
        //任务数 a = 6 , 活跃线程数5 , 任务数 < 核心线程数5 + 队列长度2 。
        //任务数 a = 7 , 活跃线程数5 , 任务数 = 核心线程数5 + 队列长度2 。
        //任务数 a = 8 , 活跃线程数6 , 任务数 < 最大线程数8 + 队列长度2 。活跃线程数是在核心线程数5的基础上，加1个活跃线程。
        //任务数 a = 9 , 活跃线程数7 , 任务数 < 最大线程数8 + 队列长度2 。活跃线程数是在核心线程数5的基础上，加2个活跃线程。
        //任务数 a = 10 , 活跃线程数8 , 任务数 = 最大线程数8 + 队列长度2 。活跃线程数是在核心线程数5的基础上，加3个活跃线程。
        //任务数 a = 11 , 活跃线程数8 , 任务数 > 最大线程数8 + 队列长度2 。抛出异常
总结：
随着任务数量的增加，会增加活跃的线程数。
当活跃的线程数 =   核心线程数，此时不再增加活跃线程数，而是往任务队列里堆积。
当任务队列堆满了，随着任务数量的增加，会在核心线程数的基础上加开线程。
直到活跃线程数 = 最大线程数，就不能增加线程了。
如果此时任务还在增加，则： 任务数11 > 最大线程数8 + 队列长度2 ，抛出异常RejectedExecutionException，拒绝任务。
    对于存活时间 这儿指的是当没有任务时 超出核心的线程 会在60S过后死亡  当然核心线程也可以设置时间
    
# Java比较常用的线程池和底层队列（只挑两个常用的）
    一、Executos.newCachedThreadPool() 可缓存线程池：底层使用SynchronousQueue(无缓冲队列)
        无缓冲队列:只作调度，不管理 可以理解为长度为0的队列。
        可缓存线程池:
            优点:
                可以灵活的创建线程、创建数量几乎没有上限（实际也有，底层默认最大的线程数是int.value）
                ，同时当没有任务时或存在空闲线程时 超过存活时间（默认60L）可以灵活回收 不会占用资源
            缺点: 由于int.value 一般机器都不会有这么大的内存使用、所以很容易造成内存溢出
            使用: 必须控制任务量
    二、Executos.newFiexdThreadPool() 定长线程池；底层使用 LinkedBlockingQueue (无界队列)
        有界队列:如果线程阻塞或者消费速度过低 会导致队列无限大 最后内存溢出 （其实一般情况下还是不会出现这种）,所以使用无界队列 线程池的最大线程数相当于无效
        定长线程池: 始终维护一个定长的核心线程数 没有任务也会占用一定的资源  当然这个基本可以忽略
        
# 规范 不允许通过Executos.newCachedThreadPool()这种方式创建线程池 
    这样的方式创建的线程池都会有各种优缺点 要么使用Java的new ThreadPoolExecutor(...)创建或spring的 new ThreadPoolTaskExecutor()创建
        这样会让开发人员更好的理解各个参数的意思和优缺点  
# 线程池的执行（返回值）
    execute/submit
                
    